#include "StdAfx.h"
#include "FullscreenTriangleDrawer.h"
#include "CPluginCoherentUI.h"

#include <d3d9.h>
#include <dxgi.h>
#include <d3dcommon.h>
#include <d3d11.h>

namespace CoherentUIPlugin
{

    CFullscreenTriangleDrawer::CFullscreenTriangleDrawer()
		: m_pVertexDeclaration(NULL)
		, m_pVertexBuffer(NULL)
		, m_pVertexShader9(NULL)
		, m_pPixelShader9(NULL)
		, m_pStateBlock(NULL)
		, m_pVertexShader11(NULL)
		, m_pPixelShader11(NULL)
    {
		ERenderType renderType = gEnv->pRenderer->GetRenderType();

		if (renderType == eRT_DX9)
		{
			CreateDX9Resources();
		}
		else if (renderType == eRT_DX11)
		{
			CreateDX11Resources();
		}
    }

	void CFullscreenTriangleDrawer::CreateDX9Resources()
	{
		HRESULT hr = S_OK;

		float VertexData[] =
		{
			-1.0f,  1.0f, 0.0f, 0.0f, 0.0f,
			 3.0f,  1.0f, 0.0f, 2.0f, 0.0f,
			-1.0f, -3.0f, 0.0f, 0.0f, 2.0f,
		};

		IDirect3DDevice9* pDevice = static_cast<IDirect3DDevice9*>(gD3DDevice);

		// Vertex buffer
		hr = pDevice->CreateVertexBuffer(sizeof(VertexData), D3DUSAGE_WRITEONLY, 0, D3DPOOL_DEFAULT, &m_pVertexBuffer, NULL);
		CRY_ASSERT(SUCCEEDED(hr));

		float* pVertexBuffer = NULL;
		hr = m_pVertexBuffer->Lock(0, 0, (void**)&pVertexBuffer, 0);
		CRY_ASSERT(SUCCEEDED(hr));
		memcpy(pVertexBuffer, VertexData, sizeof(VertexData));
		m_pVertexBuffer->Unlock();

		// Vertex declaration
		D3DVERTEXELEMENT9 VertexElements[] = 
		{
			{0, 0,  D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
			{0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},
			D3DDECL_END()
		};
		hr = pDevice->CreateVertexDeclaration(VertexElements, &m_pVertexDeclaration);
		CRY_ASSERT(SUCCEEDED(hr));

		// Vertex shader

		/*
		// FSTriangle.vs
		// fxc /O2 /T vs_2_0 /E VSMain
		float Width : register(c0);
		float Height : register(c1);

		struct VertexPT
		{
			float4 PositionL : POSITION0;
			float2 TexCoord  : TEXCOORD0;
		};

		VertexPT VSMain(VertexPT vsIn)
		{
			vsIn.PositionL += float4(-0.5 / Width, 0.5 / Height, 0, 0);
			return vsIn;
		}
		*/

		const char CompiledVS[] = 
		{
			0x00, 0x02, 0xfe, 0xff, 0xfe, 0xff, 0x28, 0x00, 0x43, 0x54, 0x41, 0x42,
			0x1c, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x02, 0xfe, 0xff,
			0x02, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00,
			0x62, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00,
			0x01, 0x00, 0x06, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
			0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x65, 0x69, 0x67,
			0x68, 0x74, 0x00, 0xab, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00,
			0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x69, 0x64, 0x74,
			0x68, 0x00, 0x76, 0x73, 0x5f, 0x32, 0x5f, 0x30, 0x00, 0x4d, 0x69, 0x63,
			0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48,
			0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43,
			0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39,
			0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 0xab, 0xab,
			0x51, 0x00, 0x00, 0x05, 0x02, 0x00, 0x0f, 0xa0, 0x00, 0x00, 0x00, 0xbf,
			0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x0f, 0x90,
			0x1f, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x80, 0x01, 0x00, 0x0f, 0x90,
			0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0xa0,
			0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x80,
			0x02, 0x00, 0x00, 0xa0, 0x06, 0x00, 0x00, 0x02, 0x01, 0x00, 0x01, 0x80,
			0x01, 0x00, 0x00, 0xa0, 0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x02, 0x80,
			0x01, 0x00, 0x00, 0x80, 0x02, 0x00, 0x55, 0xa0, 0x01, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x0c, 0x80, 0x02, 0x00, 0xaa, 0xa0, 0x02, 0x00, 0x00, 0x03,
			0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0xe4, 0x80, 0x00, 0x00, 0xe4, 0x90,
			0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x03, 0xe0, 0x01, 0x00, 0xe4, 0x90,
			0xff, 0xff, 0x00, 0x00,
		};

		hr = pDevice->CreateVertexShader((DWORD*)CompiledVS, &m_pVertexShader9);
		CRY_ASSERT(SUCCEEDED(hr));

		// Pixel shader

		/*
		// FSTriangle.ps
		// fxc /O2 /T ps_2_0 /E PSMain
		texture Texture : register(s0);

		sampler PointSampler = sampler_state
		{
			Texture = <Texture>;
			MinFilter = Point;
			MagFilter = Point;
			MipFilter = Point;
			MaxAnisotropy = 1;
			AddressU  = CLAMP;
			AddressV  = CLAMP;
		};

		struct VertexPT
		{
			float4 PositionL : POSITION0;
			float2 TexCoord  : TEXCOORD0;
		};

		float4 PSMain(VertexPT psIn) : COLOR
		{
			return tex2D(PointSampler, psIn.TexCoord);
		}

		*/

		const char CompiledPS[] =
		{
			0x00, 0x02, 0xff, 0xff, 0xfe, 0xff, 0x23, 0x00, 0x43, 0x54, 0x41, 0x42,
			0x1c, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xff,
			0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00,
			0x50, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x50, 0x6f, 0x69, 0x6e, 0x74, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72,
			0x00, 0xab, 0xab, 0xab, 0x04, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
			0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x73, 0x5f, 0x32,
			0x5f, 0x30, 0x00, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74,
			0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68,
			0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65,
			0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33,
			0x31, 0x31, 0x31, 0x00, 0x1f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x03, 0xb0, 0x1f, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90,
			0x00, 0x08, 0x0f, 0xa0, 0x42, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0f, 0x80,
			0x00, 0x00, 0xe4, 0xb0, 0x00, 0x08, 0xe4, 0xa0, 0x01, 0x00, 0x00, 0x02,
			0x00, 0x08, 0x0f, 0x80, 0x00, 0x00, 0xe4, 0x80, 0xff, 0xff, 0x00, 0x00,
		};
		hr = pDevice->CreatePixelShader((DWORD*)CompiledPS, &m_pPixelShader9);
		CRY_ASSERT(SUCCEEDED(hr));

		hr = pDevice->CreateStateBlock(D3DSBT_ALL, &m_pStateBlock);
		CRY_ASSERT(SUCCEEDED(hr));
	}

	void CFullscreenTriangleDrawer::CreateDX11Resources()
	{
		// TODO: implement
	}

    CFullscreenTriangleDrawer::~CFullscreenTriangleDrawer()
    {
		SAFE_RELEASE(m_pVertexDeclaration);
		SAFE_RELEASE(m_pVertexBuffer);
		SAFE_RELEASE(m_pVertexShader9);
		SAFE_RELEASE(m_pPixelShader9);
		SAFE_RELEASE(m_pStateBlock);

		SAFE_RELEASE(m_pVertexShader11);
		SAFE_RELEASE(m_pPixelShader11);
    }

	void CFullscreenTriangleDrawer::Draw(void* pTexture)
	{
		ERenderType renderType = gEnv->pRenderer->GetRenderType();

		if (renderType == eRT_DX9)
		{
			DrawDX9(static_cast<IDirect3DTexture9*>(pTexture));
		}
		else if (renderType == eRT_DX11)
		{
			DrawDX11(static_cast<ID3D11Texture2D*>(pTexture));
		}
	}

    void CFullscreenTriangleDrawer::DrawDX9(IDirect3DTexture9* texture)
    {
        float width = (float)gEnv->pRenderer->GetWidth();
		float height = (float)gEnv->pRenderer->GetHeight();

		IDirect3DDevice9* pDevice = static_cast<IDirect3DDevice9*>(gD3DDevice);

		m_pStateBlock->Capture();

		pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
		pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

		pDevice->SetVertexDeclaration(m_pVertexDeclaration);
		pDevice->SetStreamSource(0, m_pVertexBuffer, 0, 5 * sizeof(float));

		pDevice->SetVertexShader(m_pVertexShader9);
		pDevice->SetVertexShaderConstantF(0, &width, 1);
		pDevice->SetVertexShaderConstantF(1, &height, 1);

		pDevice->SetPixelShader(m_pPixelShader9);
		pDevice->SetTexture(0, texture);

		pDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 3);

		m_pStateBlock->Apply();
    }

    void CFullscreenTriangleDrawer::DrawDX11(ID3D11Texture2D* texture)
    {
        // TODO: implement + cache a SRV for the resource
    }
}
